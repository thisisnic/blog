{
  "hash": "940651cfc2aa77e29ed7a816c96c4f60",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Exploring querychat: talk to your data in a Shiny app\"\nauthor: \"Nic Crane\"\ndate: \"2026-01-25\"\ncategories: [R, Shiny]\n---\n\n![](logo.png){width=200 fig-align=\"center\"}\n\nI was excited to see the release of the [querychat](https://cran.r-project.org/web/packages/querychat/index.html) package on CRAN recently. I first noticed this package on [Posit's GitHub](https://github.com/posit-dev/querychat), and was really curious to see what it did. In short, it lets you ask questions to a chatbot which then generates SQL and queries a data frame or database connection to answer your question.\n\n## Reproducibility through SQL\n\nIt's a really exciting and powerful tool because it allows you to overcome some of the key issues with using LLMs for data analysis - LLMs are often poor at many tasks to do with numbers, and in most data analysis contexts we need reproducible and accurate results. \n\nUnder the hood it uses DuckDB, and tibbles are converted into DuckDB tables which can then be queried using SQL.\n\nIn translating questions into SQL we have repeatable code that we can run again separately, and it's a small leap from there to ensure that the SQL is correct and the LLM response represents it faithfully to get accurate answers.  \n\n## Examples\n\n### Filtering the data\n\nYou can create the simplest possible app by calling the `querychat_app()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(querychat)\n\nquerychat_app(mtcars)\n```\n:::\n\n\nquerychat can filter data shown in the table, only having access to summary statistics, not the raw values.\n\n![](filter.png)\n\nThe summary statistics provided are the database schema; in the case of mtcars, it looks like this:\n\n```text\nYou have access to a DuckDB SQL database with the following schema:\n\n<database_schema>\nTable: mtcars\nColumns:\n- mpg (FLOAT)\n  Range: 10.4 to 33.9\n- cyl (FLOAT)\n  Range: 4 to 8\n- disp (FLOAT)\n  Range: 71.1 to 472\n- hp (FLOAT)\n  Range: 52 to 335\n- drat (FLOAT)\n  Range: 2.76 to 4.93\n- wt (FLOAT)\n  Range: 1.513 to 5.424\n- qsec (FLOAT)\n  Range: 14.5 to 22.9\n- vs (FLOAT)\n  Range: 0 to 1\n- am (FLOAT)\n  Range: 0 to 1\n- gear (FLOAT)\n  Range: 3 to 5\n- carb (FLOAT)\n  Range: 1 to 8\n</database_schema>\n```\n\nThe data sent contains column names, types, and value ranges.\n\n## Keeping your data private\n\nWhen querychat has full access to the data, it can perform aggregations and use the results to inform answers to questions.\n\n![](query_allowed.png)\n\nHowever, you can configure querychat to only have data filtering enabled, without the results being returned to the LLM.  The LLM still has access to the information in the schema, which is provided as part of the default system prompt.  \n\nSetting `tools = \"update\"` disables the query tool entirely, preventing the LLM from seeing any of the data beyond the information passed through in the schema.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(querychat)\n\nquerychat_app(mtcars, tools = \"update\")\n```\n:::\n\n\n![](query_disallowed.png)\n\n## Learn more\n\nLLMs are going to have a huge impact on how we communicate with and about data, and so the querychat package is a huge step forward in this regard.  If you want to learn more, here's a more detailed post on the [Shiny blog](https://shiny.posit.co/blog/posts/querychat-python-r/) by Veerle Eeftink - van Leemput, or check out her video below.\n\n{{< video https://www.youtube.com/watch?v=EQjr0p25KS8 >}}",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}